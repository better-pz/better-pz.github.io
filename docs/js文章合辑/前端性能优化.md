# 性能优化

## 为什么关注性能优化

在当今的前端开发中, 前端项目越来越复杂,
重点关注的问题:

- vue 项目中的优化
- 对于网络层面可以优化哪些问题
- 执行层面可以优化哪些问题
- 对于性能优化还能做些什么

## vue 的性能优化

1. 编码阶段

- 尽量减少 data 中的数据,data 中的数据都会增加 getter 和 setter, 会收集对应的 watcher
- v-if 和 v-for 不能连用
- 如果需要使用 v-for 给每项元素绑定事件时使用事件代理
- spa 页面采用 keep-alive 缓存组件
- 路由懒加载以及异步组件
- key 保证唯一性
- 图片懒加载, 虚拟滚动, 防抖节流

2. seo 优化

- 预渲染
- 服务端渲染 SSR

3. 打包优化

- 压缩代码
- 使用 cdn 加载第三方模块

## 图片加载优化

- 使用懒加载
- img 上的 srcset 属性
- picture 标签
- 新的图片编码格式
- lient Hints

### Client Hints

client hints 是指通过客户端信息来进行资源选择的一种方法,客户端信息一般是指图片宽度,DRP 和视窗宽度,基本原理是在 http 传输中加入先关的 header,让服务器选择一张合适的图片返回给客户端,使用方式
**Client Hints 使用方式**
要使用 Client Hints 需要在

```js
<meta http-equiv="Accept-CH" content="DPR, Viewport-Width">
```

浏览器在向服务器请求图片的时候，就会附带上两个额外的 header

```js
DPR: 2
Viewport-Width: 535
```

上述设置的参数可见客户端的像素密度是 2，viewport 的宽度是 535 像素，这样服务端就可以根据要求返回参数了，但是这个方式的兼容性不好，Responsive images 是更为常用的方法

## Responsive images

Responsive images 将图片进行区分的过程放到了浏览器上，一般来说组成 Responsive images 的标签的和属性有 img 标签上的 srcset，size 属性，以及 picture 和 source 标签

### srcset 和 sizes

用 MDN 的一个例子来理解

```js
<img srcset="elva-fairy-480w.jpg 480w,
             elva-fairy-800w.jpg 800w"
     sizes="(max-width: 600px) 480px,
            800px"
     src="elva-fairy-800w.jpg"
     alt="Elva dressed as a fairy">

```

- size
  理解起来就是留着这个图片的空间是多少,假设我放置的这个图片的容器是 800px，需要填满这个容器就是 sizes="800px",size 支持媒体查询来区分不同的 slot，不同的 solt 用逗号分开如上例，意思就是当 viewport 宽度大于 600px 的时候，slot 宽度为 800px，否则为 480px，当没有图片刚好匹配 slot 宽度时，浏览器会选择第一张比 slot 宽的图片。

- srcset
  决定了可以使用的图片来源，如上就是用可以根据 size 定义的空间来自动选择对应的图片资源

### picture 标签

根据媒体选择区分不同图片来源的功能

```js
<picture>
  <source media="(max-width: 799px)" srcset="elva-480w-close-portrait.jpg">
  <source media="(min-width: 800px)" srcset="elva-800w.jpg">
  <img src="elva-800w.jpg" alt="Chris standing up holding his daughter Elva">
</picture>

```

source 标签标明可以选择的图片来源，浏览器会使用第一个匹配的 source 作为图片来源
如上例中就是在窗口宽度在大于等于 800px 的时候会使用第二个 source，否则使用第一个 source
在最后一个 source 后面要加上一个 img 标签，一是为了在没有 source 匹配时有默认显示的图片，二是当浏览器不支持 picture 时可以平稳回退

## picture 于 srcset 的区别

从浏览器的匹配的逻辑来看很容易区分

```
picture:media -> source
srcset:media -> slot -> source
```

srcset 匹配的图片依据的是图片所占的空间，picture 是根据屏幕的宽度进行匹配
同时 picture 可以根据图片格式进行选择

```js
<picture>
  <source srcset="mdn-logo.svg" type="image/svg+xml">
  <img src="mdn-logo.png" alt="MDN">
</picture>

```

# 长列表渲染优化

对于长列表的优化

# 首屏加载优化

- 预解析: 先解析 DNS 获取域名对应 IP-pre-parse
- 预加载: 延后加载无需立即用到的资源,确保使用时已加载-pre-load
- 预渲染: 延后渲染立即打开的页面,确保使用时已渲染 pre-render
- 懒加载: 延后加载无需立即渲染的资源,进入区域才加载 lazy-load
- 懒执行: 延后执行无需立即处理的逻辑,等到使用时才执行 lazy-run

# 九大策略

过程趋势来看性能优化都可以分为**网络层面**和**渲染层面**;
从结果趋势来看,性能优化可以分为时间层面和体积层面,简单的来说既是要在访问网站使前端页面快准狠的呈现在用户层面

## 网络层面

使资源体积更小加载更快

- 构建策略: 基于构建工具(webpack)
- 图像策略: 基于图像类型(图片资源合理运用,图片懒加载)
- 分发策略: 基于内容分发网络 (CDN)
- 缓存策略: 基于浏览器缓存(强制缓存 / 协商缓存)

### 构建层面

主要就是围绕 webpack 做相关处理,最重要的就是从时间层面和体积层面入手

- 减少打包时间: `缩减范围`,` 缓存副本`,` 定时搜索`, `提前构建`, `并行构建`, `可视构建`
- 减少打包体积: ` 分割代码`, `摇树优化`, `动态垫片`, `按需加载`, ` 作用提升`, `资源压缩`

## 图片策略

- 图片选型 jpg 体积小,质量中,压缩有损, 使用场景:背景图
- 图片压缩 使用图片压缩工具将图片压缩

### 分发策略

围绕内容分发网络做相关处理

- 所有静态资源走 CDN
- 把静态资源与页面至于不同的域名下:避免请求带上 cookie

内容分发网络简称为 CDN 指一组分布在各地存储数据副本并可以根据就近原则满足数据请求的服务器,核心就是缓存和回源
缓存就是将资源缓存到 cnd 服务器中,回溯及时资源过期或者不存在的时候就向上层服务器请求并复制到 cnd 服务器中

好处: 使用 cdn 可以降低网络阻塞,提高用户访问响应速度和命中率, 构建在现有网络基础上的只能虚拟网络, 依靠部署在各地服务器,通过中心平台的调度,负载均衡,内容发布等功能模块,是的用户就近获取所需资源

### 缓存策略

围绕浏览器缓存做相关处理
遵循以下五点就能发挥浏览器缓存最大作用

- 考虑拒绝一切缓存策略
- 资源是否每次都要向服务端请求
- 考虑资源是否被代理服务器缓存
- 考虑缓存过期时间
- 考虑协商缓存

## 渲染层面

渲染层面的性能优化，就是让代码解析更好更快,于是总结了如下策略

- css 策略: 基于 css 规则
- DOM 策略: 基于 DOM 操作
- 阻塞策略: 基于脚本加载
- 回流重绘策略: 基于回流重绘
- 异步更新策略: 基于异步更新

以上五方面都是编写代码时完成,充满在整个项目流程的开发阶段,所以在我们的项目开发过程中时刻要秉承这个这些策略来编写代码,才能高效完成性能良好的代码,渲染层面的吸能优化更多都是体现在编码细节上,而并非实体代码

### css 策略

- 避免为 ID 选择器添加多余的选择器
- 避免使用便签选择器代替类选择器
- 避免使用通配选择器,只对目标节点声明规则
- 避免重复配置重复定义,关注可继承属性

### DOM 策略

- 缓存 DOM 计算属性
- 避免过多 DOM 操作
- 使用 DOMFragment 缓存批量化 DOM 操作

### 阻塞策略

- 脚本与 DOM/其他脚本的依赖关系很强:对 script 设置 defer
- 脚本与 DOM/其他脚本依赖关系不强: 对 script 设置 async

### 回流重绘策略

- 缓存 DOM 计算属性
- 使用类合并样式,避免逐条改变样式
- 使用 display 控制 DOM 显示隐藏

### 异步更新策略

- 在异步任务中修改 DOM 时把其包装成微任务
