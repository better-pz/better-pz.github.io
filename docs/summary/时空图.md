## 技术实现

使用 `canvas`原生 + `zrender`库 实现

## 原生 canvas 绘制时间轴

时间轴功能：

- 时间刻度绘制
- 拖拽移动
- 放大缩小

### 1. 时间刻度绘制实现

主要使用`add_graduations(startTimestamp)`函数实现刻度的计算与绘制，参数`startTimestamp` : 偏移的距离

根据刻度线主要需要确定的是，
**刻度线的高度**: `lineH`，

**刻度数量**:`numSteps`，

**刻度之间的距离**:`graduationLeft`循环后每个时间点的位置根据左边起点计算, 距离=开始的偏移距离+格数*px/格*每格之间的基数

当确定了每个刻度(**时间节点**)的位置之后,通过`drawLine(beginX, beginY, endX, endY, color, width)`方法进行绘制

```js
    /**
     * 绘制添加刻度
     */
    addGraduations(startTimestamp) {
      let pxPerStep = this.graduation_step; // px/格 默认最小值20px
      let numSteps = this.months * (this.yearLists.length - 1); //总格数
      let graduationLeft;
      let lineH; // 刻度线高度
      let px_offset = startTimestamp; //开始的偏移距离 px
      // 左边临界值
      if (px_offset > 20) {
        px_offset = 20;
      }
      // 一年的距离
      this.yearWidth = this.months *  this.graduation_step* this.basePx
      console.log("一年的距离",this.yearWidth);

      for (let i = 0; i < numSteps; i++) {
        // 每十个定义为标记年份节点
        graduationLeft = px_offset + i * pxPerStep *this.basePx; // 距离=开始的偏移距离+格数*px/格
        if (i % this.months == 0) {
          lineH = 25;
          let time = this.yearLists[i / this.months];
          this.ctx.fillText(time, graduationLeft - 10, 50);
        } else {
          lineH = 15;
        }
        this.ctx.fillStyle = this.fontColor; // 除了0点 以外字体的颜色
        this.drawLine(
          graduationLeft,
          0,
          graduationLeft,
          lineH,
          this.scaleLineCorols, // 刻度线颜色
          1
        );
      }
    },
```

### 2. 拖拽移动

canvas 的动画都是通过 **清屏-更新-渲染**实现的

拖拽移动的效果的实现是通过 `mousemoveFunc(e)`实现的

根据计算**鼠标拖动移动的距离**来更改 绘制添加刻度开始偏移的距离 `startTimestamp` 来实现

时间轴的拖动跟上面部门展示模块联动也是根据**鼠标拖动移动的距离**来改变对应的位置

```js
    mousemoveFunc(e) {
      let pos_x = this.get_cursor_x_position(e);
      if (this.g_isMousedown) {
          this.clearCanvas();
        let diff_x = pos_x - this.g_mousedownCursor; // 记录移动的位置
        this.startTimestamp = this.startTimestamp + Math.round(diff_x);
        this.$emit("changex", this.startTimestamp);
        this.init(this.startTimestamp);
        this.g_isMousemove = true;
        this.g_mousedownCursor = pos_x;
      }
    },
```

### 3. 放大缩小

滚轮放大缩小，以时间轴中心为准 `mousewheel`事件,

放大缩小优先使得`basePx`变大缩小,这样在改变刻度数量之前可以实现刻度之间放大缩小的效果,

再根据`zoom`改变的数据确定放大缩小所展示的月数

```js
    mousewheelFunc() {
      if (event && event.preventDefault) {
        event.preventDefault();
      } else {
        window.event.returnValue = false;
        return false;
      }

      let e = window.event || event;
      let delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));


      if (delta > 0) {
        // 缩小
        this.basePx = this.basePx + 0.2;
        this.zoom++;
        if (this.zoom >= 12) {
          this.zoom = 12; //放大最大12个月
        }
      } else if (delta < 0) {
        // 放大
        this.zoom--;
        this.basePx = this.basePx - 0.2;
        if (this.zoom <= 2) {
          this.zoom = 2; //缩小最小2个月
        }

      }

      if (this.zoom % 2 === 0) {
        this.months = this.zoom;
        this.basePx = 1.5;

      }
      this.clearCanvas();

      this.init(this.startTimestamp);
    },
```

## zrender 结构图谱的实现
